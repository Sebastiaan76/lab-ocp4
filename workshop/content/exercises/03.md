_From the very beginning, one of the main objectives of the OpenShift project was to make it really easy for developers to get code running on the platform._ 

Use Source 2 Image to build and launch the application on OpenShift 

"oc new-app" is the command that can initialize an application in various ways on OpenShift. 
You will use it to get your source code running on OpenShift. 

In this lab you will build your application in a container running on OpenShift itself. This is done using Source 2 Image (s2i) which does the following:

1. Launches a container from a "builder image" of the matching runtime.  In this case that's a python 2.7 builder image.
1. Executes a build of the application in the running builder container.
1. After a successful build, s2i commits a new image containing the application and pushes it into the internal registry of OpenShift. 
1. The container is launched (or updated) because the image has been created (or updated). 

Using the following "--dry-run" option, you can first see what the "new-app" command will do. 


 - ``Note: Normally the "new-app" command could automatically select a matching builder image based on the source
code but since our code specifically requires Python version 2.7 to function properly we explicitly provide the name
and version of the builder image we want to use (python:2.7).``

Run the following command in the lower terminal so we can view the running containers/pods during the rest of the labs:

```execute-2
watch "oc get pods | grep -e ^db- -e ^vote-app- | grep -v ' Completed '"
```

Run the command and see what is will do and compare this to the explanation above. 

```execute
oc new-app python:2.7~. --name vote-app --dry-run
```

The above command does the following:

1. looks into the current working directory ".", detects python source code and determines its associated GitHub repository. 
1. creates a build object called a ``build configuration`` (BC).  The build configuration knows:
   1. the location of the python ``builder image`` repository
   1. where to fetch the source code from, e.g. the GitHub repository
   1. knows the name of the output image which will be pushed into the internal container registry 
1. creates ``image streams`` (IS) (a.k.a. OpenShift image objects) to track the builder and the final application image
1. these image streams are able to detect when images are updated and trigger a rebuild or a re-deployment of the application  
1. creates a deployment object called a ``deployment configuration`` (DC).  The deployment configuration knows:
   1. how to re-deploy the application should the image be updated
1. creates a ``service object`` to enable discovery and access to one or more running application containers. 


If there are no warnings or errors and all looks well, now execute the command without the --dry-run option:

```execute
oc new-app python:2.7~. --name vote-app 
```

This command will list out all the OpenShift objects that were created.

 - ``Note: Should the build configuration already exists from a previous invocation, start the build again with the following command:``

```execute
oc start-build vote-app 
```

In the 2nd terminal window you can see the build container running.  That's the one that's building your vote application. 

You can view the build process in the console and also on the command line, like this:

```execute 
oc logs bc/vote-app --follow 
```

Wait for the build to finish.

You will see the following amongst the output:

```
...
STEP 8: RUN /usr/libexec/s2i/assemble
...
STEP 10: COMMIT temp.builder.openshift.io/...
...
Successfully pushed ...
Push successful
```

What happens during the build?

1. the source code is cloned.
1. the python builder image is launched and the code copied intro it.
1. the s2i assemble script is executed.  It knows how to build a python application.
1. the python dependencies are installed 
1. the running container is committed and new image is created
1. the image is then pushed into OpenShift's internal container registry

After the build the image is automatically launched and a pod created.

In the 2nd terminal window you can see the build container has completed ``vote-app-1-build`` and a new application container is starting ``vote-app-1-xxyyzz``.

You can run the following command or view the 2nd terminal window.

```execute
oc get pods
```

You should see something similar to this:

```
NAME               READY     STATUS      RESTARTS   AGE
vote-app-1-build   0/1       Completed   0          4m
vote-app-1-deploy  0/1       Running     0          3m
vote-app-1-gxq5k   1/1       Running     0          30s
```

1. The vote-app-1-build pod has completed what it was doing, namely building the python application. 
1. The vote-app-1-deploy pod was launched to deploy the vote application pod.
1. Now the vote-app-1-gxq5k pod has started.

By default, the application is not accessible from outside of OpenShift. Now, expose the application to the external network:

```execute
oc expose svc vote-app
```


To get access to the running application we need to expose it to the outside world. 

FIXME: Explain the route concept ... 

Create and check a route object:

```execute 
oc get svc
```

```execute 
oc get route
```

To check the application is working you can either use curl or load the URL into your browser.

Use curl to check the app is working

```execute 
curl http://vote-app-%project_namespace%.%cluster_subdomain%/ 
```

or use another way which checks for the expected output:

```execute 
curl -s http://vote-app-%project_namespace%.%cluster_subdomain%/ | grep "<title>"
```

You should see... FIXME

Test the application in a browser with the following URL:

[Open the Vote Application](http://vote-app-%project_namespace%.%cluster_subdomain%/)


---
Optionally: If you are interested ... configure a webhook in GitHub to trigger the s2i build on code change. 

You can view the webhook and the secret to use here: 

```execute
getwebhook vote-app %cluster_subdomain%
```

Remember to set the ``Content type`` to ``application/json``

FIXME: get instructions for this 

Now, when you make a change to the code, commit and push it, a fresh build will be triggered. 

The following command makes a change to the Dockerfile, commits and pushes the change to GitHub.  This will trigger a
re-build and a re-deployment of the application.

FIXME: Is this useful?

```execute
echo >> Dockerfile && git commit -m "update" . && git push
```


---
---
Example output of a full application build:

```
$ oc logs bc/vote-app
Cloning "https://github.com/sjbylo3/flask-vote-app.git" ...
        Commit: 8a39cbe3e4ef74da488d997f4b4fa405aa40fa6e (x)
        Author: Your Name <you@example.com>
        Date:   Wed Jul 3 14:55:30 2019 +0000
Caching blobs under "/var/cache/blobs".
Getting image source signatures
Copying blob sha256:db1d55616933198cd32cb3a3a658a903a9205c733af15ca6423268d83a2a5840
Copying blob sha256:c6e3f631f202ad743e78a73f9c01ce55e9769686be1edabb3f5d3feab7561cf2
Copying blob sha256:d09f4fbfc5a9483fa192bbc034da939b9073ffff83a7145ff328b3c5294caa61
Copying blob sha256:9185eeb129b69fb700e4655c62a3c123fd5d72c2971665c15610109f032368ee
Copying blob sha256:18f0f6de460133d70b9f6a0d1c7f2f682c324471861334b6b329a5c04653d834
Copying config sha256:07822e6843338f8ad388f1f34294082de46f7e897c6a743d60dde1e3af55be71
Writing manifest to image destination
Storing signatures
07822e6843338f8ad388f1f34294082de46f7e897c6a743d60dde1e3af55be71
Generating dockerfile with builder image image-registry.openshift-image-registry.svc:5000/openshift/python@sha256:b604de44d1d298873ba1620e2941536a4ec2c836b43eafdcbcd61132bd446d70
STEP 1: FROM image-registry.openshift-image-registry.svc:5000/openshift/python@sha256:b604de44d1d298873ba1620e2941536a4ec2c836b43eafdcbcd61132bd446d70
STEP 2: LABEL "io.openshift.build.source-location"="https://github.com/sjbylo3/flask-vote-app.git" "io.openshift.build.image"="image-registry.openshift-image-registry.svc:5000/openshift/python@sha256:b604de44d1d298873ba1
620e2941536a4ec2c836b43eafdcbcd61132bd446d70" "io.openshift.build.commit.author"="Your Name <you@example.com>" "io.openshift.build.commit.date"="Wed Jul 3 14:55:30 2019 +0000" "io.openshift.build.commit.id"="8a39cbe3e4ef
74da488d997f4b4fa405aa40fa6e" "io.openshift.build.commit.ref"="master" "io.openshift.build.commit.message"="x"
STEP 3: ENV OPENSHIFT_BUILD_NAME="vote-app-1" OPENSHIFT_BUILD_NAMESPACE="kubeex" OPENSHIFT_BUILD_SOURCE="https://github.com/sjbylo3/flask-vote-app.git" OPENSHIFT_BUILD_REFERENCE="master" OPENSHIFT_BUILD_COMMIT="8a39cbe3e
4ef74da488d997f4b4fa405aa40fa6e"
STEP 4: USER root
STEP 5: COPY upload/src /tmp/src
STEP 6: RUN chown -R 1001:0 /tmp/src
time="2019-07-04T00:46:01Z" level=warning msg="pkg/chroot: error unmounting \"/tmp/buildah535376182/mnt/rootfs\": error checking if \"/tmp/buildah535376182/mnt/rootfs/sys/fs/cgroup/rdma\" is mounted: no such file or dire
ctory"
time="2019-07-04T00:46:01Z" level=warning msg="pkg/bind: error unmounting \"/tmp/buildah535376182/mnt/rootfs\": error checking if \"/tmp/buildah535376182/mnt/rootfs/sys/fs/cgroup/rdma\" is mounted: no such file or direct
ory"
STEP 7: USER 1001
STEP 8: RUN /usr/libexec/s2i/assemble
---> Installing application source ...
---> Installing dependencies ...
You are using pip version 7.1.0, however version 19.1.1 is available.
You should consider upgrading via the 'pip install --upgrade pip' command.
Collecting flask (from -r requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/9a/74/670ae9737d14114753b8c8fdf2e8bd212a05d3b361ab15b44937dfd40985/Flask-1.0.3-py2.py3-none-any.whl (92kB)
Collecting flask-sqlalchemy (from -r requirements.txt (line 2))
  Downloading https://files.pythonhosted.org/packages/08/ca/582442cad71504a1514a2f053006c8bb128844133d6076a4df17117545fa/Flask_SQLAlchemy-2.4.0-py2.py3-none-any.whl
Collecting mysql-python (from -r requirements.txt (line 3))
  Downloading https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip (108kB)
Collecting itsdangerous>=0.24 (from flask->-r requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/76/ae/44b03b253d6fade317f32c24d100b3b35c2239807046a4c953c7b89fa49e/itsdangerous-1.1.0-py2.py3-none-any.whl
Collecting Werkzeug>=0.14 (from flask->-r requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/9f/57/92a497e38161ce40606c27a86759c6b92dd34fcdb33f64171ec559257c02/Werkzeug-0.15.4-py2.py3-none-any.whl (327kB)
Collecting Jinja2>=2.10 (from flask->-r requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/1d/e7/fd8b501e7a6dfe492a433deb7b9d833d39ca74916fa8bc63dd1a4947a671/Jinja2-2.10.1-py2.py3-none-any.whl (124kB)
Collecting click>=5.1 (from flask->-r requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/fa/37/45185cb5abbc30d7257104c434fe0b07e5a195a6847506c074527aa599ec/Click-7.0-py2.py3-none-any.whl (81kB)
Collecting SQLAlchemy>=0.8.0 (from flask-sqlalchemy->-r requirements.txt (line 2))
  Downloading https://files.pythonhosted.org/packages/62/3c/9dda60fd99dbdcbc6312c799a3ec9a261f95bc12f2874a35818f04db2dd9/SQLAlchemy-1.3.5.tar.gz (5.9MB)
Collecting MarkupSafe>=0.23 (from Jinja2>=2.10->flask->-r requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/b9/2e/64db92e53b86efccfaea71321f597fa2e1b2bd3853d8ce658568f7a13094/MarkupSafe-1.1.1.tar.gz
Installing collected packages: itsdangerous, Werkzeug, MarkupSafe, Jinja2, click, flask, SQLAlchemy, flask-sqlalchemy, mysql-python
  Running setup.py install for MarkupSafe
  Running setup.py install for SQLAlchemy
  Running setup.py install for mysql-python
Successfully installed Jinja2-2.10.1 MarkupSafe-1.1.1 SQLAlchemy-1.3.5 Werkzeug-0.15.4 click-7.0 flask-1.0.3 flask-sqlalchemy-2.4.0 itsdangerous-1.1.0 mysql-python-1.2.5
STEP 9: CMD /usr/libexec/s2i/run
STEP 10: COMMIT temp.builder.openshift.io/kubeex/vote-app-1:23b730bc
Getting image source signatures
Copying blob sha256:8783de338a118d308a5f8e00576afc318fac3a8a35767d95948493915cc249a8
Copying blob sha256:16d1101dbd1155a2372165ab13f12867fdedbc3010c4a8258b6d5ec6cbd5df0a
Copying blob sha256:16dbd38945ab2db17f5f14c3c7c354044f016367b9f1b665b4e7e254636b046e
Copying blob sha256:012ecb7f1b331a8e71245bdedcead24cdd240bf4ab49b061ea4875e06fe0fc59
Copying blob sha256:87694c889a4618b35ac40dab8c3ac77028e9aa8f461107437661715b06302a91
Copying blob sha256:03ae79bdb9de2991d902d61f2293321aa384f24fa7ec5dfa04d8b357ca282849
Copying config sha256:c86d05964d9113b191e52f25aa7bb405aedf11e6ad2f6a5528af3a9989a7f048
Writing manifest to image destination
Storing signatures
--> c86d05964d9113b191e52f25aa7bb405aedf11e6ad2f6a5528af3a9989a7f048

Pushing image image-registry.openshift-image-registry.svc:5000/kubeex/vote-app:latest ...
Getting image source signatures
Copying blob sha256:03ae79bdb9de2991d902d61f2293321aa384f24fa7ec5dfa04d8b357ca282849
Copying blob sha256:18f0f6de460133d70b9f6a0d1c7f2f682c324471861334b6b329a5c04653d834
Copying blob sha256:db1d55616933198cd32cb3a3a658a903a9205c733af15ca6423268d83a2a5840
Copying blob sha256:c6e3f631f202ad743e78a73f9c01ce55e9769686be1edabb3f5d3feab7561cf2
Copying blob sha256:d09f4fbfc5a9483fa192bbc034da939b9073ffff83a7145ff328b3c5294caa61
Copying blob sha256:9185eeb129b69fb700e4655c62a3c123fd5d72c2971665c15610109f032368ee
Copying config sha256:c86d05964d9113b191e52f25aa7bb405aedf11e6ad2f6a5528af3a9989a7f048
Writing manifest to image destination
Storing signatures
Successfully pushed //image-registry.openshift-image-registry.svc:5000/kubeex/vote-app:latest@sha256:c4efcc10c119d340d67ff4a0f2924d9864f526e2b0c8699043d3c25f1a39bc67
Push successful
```

